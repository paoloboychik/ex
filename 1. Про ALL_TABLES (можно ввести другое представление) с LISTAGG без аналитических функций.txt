
DEFINE tabname = '&str';

/*Сначала получим список УНИКАЛЬНЫХ (с помощью DISTINCT) имен столбцов из заданной таблицы*/
/*ALL_TAB_COLUMNS – таблица, которая содержит информацию о таблицах, столбцах и представлениях.*/
WITH temp0 as (
    select distinct column_name as col_name
    from  all_tab_columns 
    WHERE LOWER(table_name) = LOWER(TO_CHAR('&tabname'))
),
/*Мы объединяем значения столбца COL_NAME запроса temp0 в одну строку list*/
temp1 AS 
(SELECT ' '||LISTAGG(col_name, ', ') WITHIN GROUP (ORDER BY col_name) list 
FROM temp0),
/*LISTAGG - объединяет значения столбца COLUMN_NAME, разделяя их запятой, в алфавитном порядке.*/

temp2(list, cols, point) AS(
    SELECT list, 
        CASE
        /*Если строка list не содержит запятых или длина исходной строки list не превосходит 50 символов, 
        выводим строку в колонке COLS. Иначе выполняем операцию REGEXP_SUBSTR(SUBSTR(list, 1,50), '.*,'), где
        SUBSTR(list, 1,50) – подстрока строки list, с 1 по 50 символ;
        
        REGEXP_SUBSTR(SUBSTR(list, 1,50), '.*,') – подстрока, которая содержит несколько имен колонок 
        (получим значение столбца COLS), разделенных запятой.
        То есть функция SUBSTR «отрезает» ровно 50 символов, а REGEXP_SUBSTR оставляет все полные имена столбцов.*/
            WHEN LENGTH(list)<=50 THEN list 
            ELSE REGEXP_SUBSTR(SUBSTR(list, 1,50), '.*,|.*\w$') 
        END cols,
        
        
        CASE
        /*В столбец LN записываем индекс следующего элемента после найденной подстроки. 
        Если вся строка list попадает в единственную строку столбца COLS (length(list)<=50),
        то номером следующего индекса будет длина list + 1, чтобы в дальнейшем никаких разделений строки не происходило
        (просто шаблон '.*,' может захватить лишь часть строки, например, если в ней всего 2 столбца,
        из-за чего получится разделение строки list не смотря на то, что её длина не превосходит 50 символов, 
        нам нужно этого избежать)*/
            WHEN LENGTH(list)<=50 THEN LENGTH(list)+1
            ELSE LENGTH(REGEXP_SUBSTR(SUBSTR(list, 1,50), '.*,|.*\w$')) + 1 END LN 
    FROM temp1
    
    /*с помозью иерархического запроса temp2 объединяем полученные значения со значениями остальных имен столбцов,
    которые содержаться в строке LIST, до момента пока не дойдем до конца.*/
    UNION ALL 
    SELECT list, REGEXP_SUBSTR(SUBSTR(list, point, 50), '.*,|.*\w$'), point+LENGTH(REGEXP_SUBSTR(SUBSTR(list, point, 50), '.*,|.*\w$')) 
    FROM temp2 
    WHERE point < LENGTH(list)
),

/*Запишем номера строк в колонке COLS и сами значения колонки.*/
/*ROWNUM - нумерует строки, возвращаемые запросом. Пронумерует значения столбца COLS.*/
temp3 AS(
    SELECT ROWNUM "Номер строки", 
            cols "Список столбцов" 
    FROM temp2
)
/*В столбце "Имя представления" запишем название таблицы 'ALL_TABLES если "Номер строки" = 1, иначе просто пробел.
Далее выведем "Номер строки", "Список столбцов". 
Если в "Список столбцов" нет запятых, то в "Количество столбцов" записываем 1 иначе количество запятых.*/
SELECT CASE 
        WHEN "Номер строки" = 1 THEN UPPER(TO_CHAR('&tabname' ))
        ELSE ' ' 
        END "Имя представления", 
    "Номер строки", "Список столбцов", 

/*Количество комбинаций разделительных символов (в данном случае ', ') будет всегда на один меньше, 
чем количество имён столбцов в строке. Воспользуемся этим и с помощью функции REGEXP_COUNT сформируем
крайний правый столбец результирующей таблицы*/
    REGEXP_COUNT("Список столбцов", ', ')+1 "Количество столбцов" 
FROM temp3;
